# HPC
# [lab-1. Matrix Multiplication](https://github.com/vellarLa/HPC/blob/main/HPC_1lab.ipynb)
Параллельный алгоритм реализован с использованием функции ядра.
Тип матриц - double, BLOCK_SIZE = 16, размер матриц задается в процессе выполнения программы
Алгоритм:
1) Считывание размерности матриц
2) Создаем массивы / выделяем память на CPU
3) Создаем массивы / выделяем память на GPU / выполняем проверку на успешное вделение памяти
4) Создание обработчиков событий для учета времени умножения на GPU
5) Заполнение матриц A и B на GPU рандомными значениями (0, 1)
6) Запуск функции ядра , выполнение умножения на GPU
7) Синхронизация устройств
8) Копирование матриц на CPU
9) Умножение матриц на CPU
10) Вывод результатов
11) Освобождение памяти GPU и CPU
Результаты, программный код и комментарии приведены по ссылке.

# [lab-2. Matrix Multiplication](https://github.com/vellarLa/HPC/blob/main/HPC_2lab.ipynb)
Параллельный алгоритм реализован с использованием функции ядра.
Тип векторов - double, BLOCK_SIZE = 512, GRID_SIZE = 1024; размер матриц задается в процессе выполнения программы
Алгоритм:
1) Считывание размерности векторов
2) Создаем массивы / выделяем память на CPU
3) Создаем массивы / выделяем память на GPU / выполняем проверку на успешное вделение памяти
4) Создание обработчиков событий для учета времени сложения на GPU
5) Заполнение векторов A и B на СPU рандомными значениями (0, 1)
6) Копировние векторов с хоста на девайс
7) Запуск функции ядра , выполнение сложения на GPU
8) Синхронизация устройств
9) Копирование  на CPU
10) Умножение матриц на CPU
11) Вывод результатов
12) Освобождение памяти GPU и CPU
Результаты, программный код и комментарии приведены по ссылке.

# [lab-3. Pi-value Calculation, 1 point](https://github.com/vellarLa/HPC/blob/main/HPC_3lab.ipynb)
Параллельный алгоритм расчета значения pi реализован с использованием функции ядра.

Так как код блокнота на гитхабе отображается криво (пропущены куски), вот ссылка на колаб
https://colab.research.google.com/drive/16dynDuJATeH7hvniGIMfn0bU6nFZqSom?usp=sharing
Алгоритм:
1) С использованием библиотеки CURAND были сгенерированы N значенений (точек) на GPU (массивы X и Y).
2) Реализация функции ядра со следующими вычислениями:
* (X^2 + Y^2 < 1) ? 1 : 0
3) После выполнения функции ядра полученное значение умножалось на 4/N
4) Был реализован также алгоритм для CPU и сравнены результаты. При размерностях N=100000000 ускорение параллельного алгоритма превышало 15.
  Все результаты и графике приведены по ссылке.

# [lab-4. Salt and Pepper, 2 point](https://github.com/vellarLa/HPC/blob/main/HPC_4lab.ipynb)
Параллельный алгоритм фильтрации изображения от шумов вида "соль-перец" реализован с использованием функции ядра и модуля Pycuda для работы с CUDA на Python.
Алгоритм:
1) Считывание исходного изображения MxN из файла.
2) Изменение размеров изображения. Добавления шумов "соль-перец" к исходному изображению, используя функцию-генератор.
3) Определение объекта текстурной памяти tex на GPU.
4) Объявление функции saltAndPepper, которая будет выполняться на каждом потоке GPU и будет выполнять медианную фильтрацию изображения с икном фильтра размерами 3x3.
5) С помощью driver.matrix_to_texref загрузка исходного изображения в текстуру tex.
6) Запуск saltAndPepper.
7) Анализ результатов по сравнению с последовательным вариантом.
На больших размерностях изображения удалось достигнуть ускорения в десяток тысяч раз.
Все результаты и графике приведены по ссылке.
